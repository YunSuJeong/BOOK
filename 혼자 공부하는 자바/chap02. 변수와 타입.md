# chap02. 변수와 타입


## 02-1. 변수
> 컴퓨터 메모리(RAM)는 값을 저장할 수 있는 수많은 번지(주소)로 구성되어 있다.  
> **메모리에 값을 저장하고 싶다면 변수를 사용해 값을 지정**하면 된다.  
> 그러면 실제 메모리의 어디에 저장하고, 어떤 방식으로 저장할지는 프로그래밍 언어와 운영체제가 정한다!  
> 자바의 경우는 JVM이 하는 일!

`변수(variable) : 값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름`  

### ▶︎ 변수 선언
변수에 어떤 `타입`의 데이터를 저장할 것인지, 변수 이름이 무엇인지 결정하는 것  
`타입 : 변수에 저장되는 값의 종류와 범위를 결정`
```java
// 따로 선언한 예시
int x;
int y;
int z;

// 같은 타입인 경우만 한번에 선언 가능
int x, y, z;      
```

#### 변수 이름 명명규칙
- 첫 번째 글자는 문자, '$', '_'이어야하고 숫자로 시작할 수 없다
  - 불가능한 예) 1v, @speed
- 영어 대소문자를 구분한다
  - firstname firstName은 다른 변수
- 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로
  - 예) maxSpeed, carBodyColor
- 길이 제한은 없다
- `예약어`는 사용할 수 없다.

`예약어 : 이미 해당 프로그래밍 언어에서 의미를 갖고 사용되고 있는 단어`

### ▶︎ 값 저장
**대입 연산자(=)** 사용하여 값을 저장할 수 있고
```java
int score;      // 선언
score = 90;     // 값 저장(초기값)

// 선언과 생성을 동시에
int score = 90;
```

‼️ **자바에서는 변수에 값이 저장되지 않으면 변수가 생성되지 않는다.** (선언 ≠ 생성)  
**변수에 최초로 값이 저장될 때 변수가 생성**된다 **= 변수 초기화**  
변수가 초기화되면 메모리 번지 정보를 갖게되고, 해당 메모리 번지에 값이 저장된다.

따라서 초기화되어 있지 않은 변수를 가져다 사용하려고 하면, '변수가 존재하지 않는다'는 컴파일 에러를 마주치게 된다.

### ▶︎ 변수 사용
- 변수는 출력문이나 연산식 내부에서 변수에 저장된 값을 출력하거나 연산할 때 사용  
- **또 다른 변수에 대입하여 값을 복사할 수도 있다.**
```java
int x = 10;
int y = x;      // x에 저장된 값을 y에 복사(저장)
```
### ▶︎ 변수 사용 범위
자바의 모든 변수는 중괄호 {} 블록 내에서 선언되고 사용된다.  
자신이 선언된 위치로부터 자신이 속한 블록 내부에서만 사용가능하고 밖에서는 사용할 수 없다.  

#### 📌 로컬 변수(local variable)
메소드 블록 내에서 선언된 변수  
메소드 블록 내에서만 사용되고 실행이 끝나면 메모리에서 자동으로 없어진다.

```java
public void cafe() {
  int price;
  if(...) {
    // 여기선 price 사용가능
    int option
  }
  // 여기선 option 사용 불가능
}
```


## 02-2. 기본 타입
기본 타입(primitive type) : 자바에서 제공하는 정수, 실수, 논리 값을 저장 할 수 있다.  
총 8가지!  
각 분류별 타입 종류들은 **메모리 사용 크기와 저장되는 범위가 서로 다르다**. 

<table>
  <tr>
    <th>구분</th>
    <th>저장되는 값에 따른 분류</th>
    <th>타입의 종류</th>
  </tr>
  <tr>
    <td rowspan="3">기본 타입</td>
    <td>정수 타입</td>
    <td>byte, char, short, int, long</td>
  </tr>
  <tr>
    <td>실수 타입</td>
    <td>float, double</td>
  </tr>
  <tr>
    <td>논리 타입</td>
    <td>boolean</td>
  </tr>
</table>

### ▶︎ 정수 타입
char를 제외한 저장되는 값의 허용 범위는 **-2<sup>n-1</sup>~(2<sup>n-1</sup>-1)** 이다.
(n은 메모리 bit수)  

정수 타입으로 선언된 변수에는 정수 `리터럴`을 대입해 저장할 수 있다.  
`리터럴(literal) : 프로그래머에 의해 직접 입력된 값, 상수풀에 저장된 후 변수 메모리에 복사됨`

> 💡 정수 리터럴
> 2진수 : 0b | 0B 로 시작하고 0,1로 구성  
> 8진수 : 0으로 시작하고 0-7로 구성  
> 10진수 : 소수점이 없는 0-9로 구성  
> 16진수 : 0x | 0X로 시작하고 0-9, A-F(a-f)로 구성  

‼️ 각 타입 변수에 **허용 범위를 초과한 값을 대입**한 경우 **'Type mismatch' 컴파일 에러**가 발생한다.

| 타입 | 메모리 사용 크기 | 저장되는 값의 허용 범위 |
|---|---|---|
| byte | 1byte | -128 ~ 127 |
| short | 2byte | -32,768 ~ 32,767 |
| char | 2byte | 0 ~ 65535(유니코드) |
| int | 4byte | -2,147,483,648 ~ 2,147,483,647 |
| long | 8byte | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

#### 📌 long 타입 
기본적으로 컴파일러는 정수 리터럴을 int타입으로 간주한다.  
따라서 **long 타입 변수에 정수 리터럴을 저장할 때, 정수 리터럴이 int타입 범위를 초과할 경우 리터럴 뒤에 L(l)** 을 붙여야한다.

```java
long var1 = 3000000000000;        // 컴파일 에러
long var2 = 3000000000000L;
```

#### 📌 char 타입 
**하나의 문자를 저장**할 수 있는 타입  

**문자 리터럴** : 하나의 문자를 작은따옴표(')로 감싼 것  
문자 리터럴은 `유니코드`로 변환되어 저장된다.  

**char변수에도 10진수 또는 16진수 형태로 유니코드 저장할 수 있다.** 유니코드도 정수이기 때문!  
`유니코드(Unicode) : 세계 각국의 문자를 2byte로 표현할 수 있는 숫자(0-65535)로 매핑한 국제 표준 규약`  

> 💡 문자 리터럴은 int 타입에 저장이 가능할까.?  
> 작은 따옴표로 감싼 문자 리터럴은 유니코드로 변환되기 때문에 int타입 변수에 저장할 수 있다.  
> 다만 출력 시에는 유니코드 자체가 출력된다.  
> 예) int var = 'A' (가능!) → 65로 출력됨

#### 📌 문자열 타입(String)
> String타입은 기본 타입이 아니지만, 기본 타입 못지않게 많이 쓰이기 때문에 문자 타입과 함께 가볍게 언급하고 넘어가고자 한다.  
> 6장에서 상세히 설명될 예정

`문자열`을 저장할 수 있는 타입이다.  
큰따옴표로 감싼 문자 또는 여러 개의 문자들은 유니코드로 변환되지 않기 때문에 String타입에 저장하여 사용한다.  
`문자열 : 큰따옴표(")로 감싼 문자들`  

문자열에는 `이스케이프 문자`라는 것이 있다.
`이스케이프(escape) 문자 : 문자열 내부에 역슬래시(\)가 붙은 문자`
출력을 제어하거나, 특정 문자를 문자열 내부에 포함시키고 싶을 때 사용한다.

| 이스케이프 문자 | 출력 용도 |
|---|---|
| \t | 탭만큼 띄움 |
| \n | 줄 바꿈(라인 피드) |
| \r | 캐리지리턴 |
| \" | " 출력 |
| \' | ' 출력 |
| \\ | \ 출력 |
| \u16진수 | 16진수 유니코드에 해당하는 문자 출력 |

### ▶︎ 실수 타입
소수점이 있는 실수 리터럴을 저장할 수 있는 타입 
| 타입 | 메모리 사용 크기 | 저장되는 값의 허용 범위(양수 기준) | 정밀도(소수점 이하 자리) |
|---|---|---|---|
| float | 4byte | (1.4 × 10<sup>-45</sup>) ~ (3.4 × 10<sup>38</sup>) | 7자리 |
| double | 8byte | (4.9 × 10<sup>-324</sup>) ~ (1.8 × 10<sup>308</sup>) | 15자리 |

자바는 실수 리터럴을 기본적으로 double타입으로 간주한다.  
따라서 **float 타입 변수에 실수 리터럴을 저장할 때, 리터럴 뒤에 F(f)** 를 붙여야한다.

```java
float var1 = 3.14;        // 컴파일 에러(Type mismatch)
float var2 = 3.14F;
double var2 = 3.14;
```

### ▶︎ 논리 타입
주로 **두 가지 상태값에 따라** 조건문과 제어문의 실행 흐름을 변경하는 데 사용한다.  
자바는 참과 거짓을 의미하는 **논리 리터럴로 true/false**를 사용한다. 


## 02-3. 타입 변환
> 변수 사용 시에, 한쪽 변수값을 다른 쪽 변수에 복사해서 저장할 수 있다고 했다.  
> 두 변수의 타입이 동일할 경우는 문제가 없다! (당연함)  
> **만약 두 변수 타입이 다르다면 불가능한 걸까?**

가능하다.  
다만 `타입 변환`이란 과정이 필요하다.  

`타입 변환 : 데이터 타입을 다른 데이터 타입으로 변환하는 것`

### ▶︎ 자동 타입 변환(promotion)
자동 타입 변환은 말 그대로다. **프로그램 실행 도중에 자동으로 타입 변환**이 일어난다는 것이다.  
다만 발생조건이 있는데, **값의 허용 범위가 작은 타입이 허용 범위가 큰 타입으로 저장될 때** 이다.  
반대의 경우는 불가능🙅🏻

#### 📌 허용 범위 크기순 기본 타입
byte < short < int < long < float < double

```java
// 1) byte → int
byte byteVal = 10;
int intVal = byteVal;        // 자동 타입 변환됨

// 2) long → float, double
long longVal = 5000000000L;
float floatVal = longVal;    // 5.0E9f로 자동 타입 변환되어 저장됨
double doubleVal = longVal;  // 5.0E9f로 자동 타입 변환되어 저장됨
```

**‼️ 예외적인 케이스**  
**byte타입은 char타입으로 자동변환 될 수 없다.**  
이유는 허용범위에 있다!  
char 타입은 음수를 저장 할 수 없는 범위를 가지지만, byte 타입은 음수를 포함하고 있으므로 자동변환이 불가능하다.

```java
byte byteVal = 65;
char charVal = byteVal;    // 컴파일 에러
```

#### 📌 연산에서의 자동 타입 변환
1. 정수 연산  
**정수 타입변수가 산술 연산식에서 피연산자로 사용될 때, 피연산자 중 허용범위가 큰 타입으로 자동 변환되어 연산을 수행**한다.  
따라서 연산 결과를 가장 큰 타입이 아닌 작은 정수 타입 변수에 저장하면 컴파일 에러(Type mismatch)가 발생한다.
**byte, short형 변수의 연산에서는 동일 타입 연산이어도 int타입 변수로 자동 타입 변홛되어 연산을 수행한다.**  
특별한 이유가 없는 경우 정수 연산에 사용 되는 변수는 int타입으로 선언하는 것이 좋다.  
타입 변환이 줄면 실행 성능이 향상될 수 밖에 없기 때문!  

```java
1) byte형끼리의 연산결과 저장
byte x = 10;
byte y = 20;

byte result = x + y;    // 컴파일 에러
int result = x + y;     // 30

// ‼️ 이 경우에선 '피연산자가 변수가 아니므로' int형으로 타입변환을 하지 않는다. 컴파일 단계에서 미리 연산되고, 변수에 30을 저장하도록 바이트 코드를 생성한다.
byte result = 10 + 20;

2) 서로 다른 범위의 정수 타입 연산결과 저장
int x = 10;
long y = 20;

int result = x + y;     // 컴파일 에러, y가 long형이므로 x가 long형으로 자동변환되어 연산된다. 
long result = x + y;    // 30
```

2. 실수 연산
산술 연산식에서 피연산자로 실수타입 변수가 사용될 경우, 동일한 타입의 실수 연산이라면 문제 없다!  
그러나 피연산자 중 하나가 double 타입이라면?
**다른 피연산자도 double 타입으로 자동 타입변환되어 연산을 수행하므로 연산결과는 double타입**이 된다.  
int타입 변수와 double타입 변수가 피연산자인 산술 연산식에서도 위와 동일한 과정을 거친다.  

```java
double result1 = 1.2f + 3.4;    // 1.2f가 double타입으로 자동 변환
float result2 = 1.5 + 2.3;      // 1.5와 2.3은 double타입이므로 float에 저장할 수 없다. 캐스팅 필요

int x = 1;
int y = 2;
double result = x / y;          // 결과 : 0.0, 정수끼리의 연산 결과는 정수형이고, 결과를 저장하는 타입이 double이므로 마지막에 0이 double형으로 변환되는 것임
```

3. 문자열 결합(+) 연산
피연산자 중 하나가 문자열인 경우에 나머지 피연산자도 문자열로 자동 변환되어 문자열 결합 연산을 수행한다.

- 먼저 수행된 연산이 덧셈 연산이라면 덧셈 결과를 가지고 다음 + 연산을 수행
- 먼저 수행된 연산이 결합 연산이라면 이후 + 연산은 모두 결합 연산

```java
String str = 1 + "2";        // "12"
String str = 1 + 2 + "3";    // 3 + "3" → "33"
String str = "1" + 2 + 3;    // "12" + 3 → "123"
```

### ▶︎ 강제 타입 변환(캐스팅, casting)
범위가 큰 타입을 작은 타입으로 저장할 수는 없을까?  
허용 범위가 큰 타입은 작은 타입으로는 자동 타입 변환 될 수 없다.  
자동으로 불가능하다면 강제로 바꿔버리는 방법을 사용할 수 있다.  

**큰 허용 범위 타입을 작은 허용 타입으로 강제로 나눠서 저장하는 것**을 강제 타입 변환이라고 한다.

#### 📌 캐스팅 방법
캐스팅 연산자 괄호 ()를 사용한다.

1. int → char  
수를 문자로 출력할 수 있다.  
아래 예제에서 charVal에는 65가 'A'로 변환되어 저장된다.
```java
int intVal = 65;
char charVal = (char) intVal;    // 강제 타입 변환
```

2. float, double(실수 타입) → byte, short, int, long(정수 타입)
소수점 이하 부분은 버려지고, 정수 부분만 저장된다.
```java
double doubleVal = 3.14;
int intVal = (int) doubleVal;    // 3만 저장
```

3. 문자열 ↔︎ 기본 타입
- 문자열 → 기본 타입

| 변환 타입 | 사용 예 |
|---|---|
| String → byte | Byte.parseByte("10") |
| String → short | Short.parseShort("100") |
| String → int | Integer.parseInt("1000000000") |
| String → long | Long.parseLong("10000000000") |
| String → float | Float.parseFloat("3.14") |
| String → double | Double.parseDouble("3.14") |
| String → boolean | Boolean.parseBoolean("true") |

- 기본 타입 → 문자열 : String.valueOf(기본타입값) 메소드 사용
```java
String str = String.valueOf(3);      // 결과 : "3"
```


## 02-4. 변수와 시스템 입출력
> 프로그래밍 언어에는 시스템 **표준 출력 장치**와 **표준 입력 장치** 가 있다.  
> 일반적으로 표준 출력 장치는 **모니터**🖥️, 표준 입력 장치는 **키보드**⌨️이다.  
> 변수에 저장된 값을 모니터에 출력하는 방법과 키보드로부터 데이터를 익고 변수에 저장하는 방법을 알아보자!

### ▶︎ 모니터로 변수값 출력하기
시스템 표준 출력 장치인 **System.out**을 이용하여 출력한다!

#### 📌 System.out의 메소드 종류
| 메소드 | 의미 |
|---|---|
| println(내용) | 괄호 안의 내용을 **출력하고 행을 바꿔라** |
| print(내용) | 괄호 안의 내용을 **출력만** 해라 |
| printf("형식문자열", 값1, 값2, ...) | 괄호 안의 첫 번째 **문자열 형식대로 내용을 출력**해라 |

**💡 printf 형식문자열**  
<img width="600" height="150" alt="image" src="https://github.com/user-attachments/assets/24c73fdc-dadd-43bf-87c3-98c618789a68" />
- % : 형식 문자열을 시작을 뜻함
- argument_index$ : 형식 문자열에 포함될 값이 2개 이상일 경우 순번을 지정하는 역할
  - 1$(첫 번째 값), 2$(두 번째 값)
- flags : 빈자리를 채우는 방법
  - 생략 : 왼쪽이 공백으로 채워짐
  - '-' : 오른쪽이 공백으로 채워짐
  - '0' : 공백 대신 0으로 채움
- conversion : 제공되는 값의 타입에 따라 입력
  - d(정수), f(실수), s(문자열)

- 자주 사용되는 형식 문자열
<img width="700" height="500" alt="image" src="https://github.com/user-attachments/assets/03bdb75f-7ac5-413e-a69c-8063697dad3e" />

### ▶︎ 키보드에서 입력된 내용을 변수에 저장하기
#### 📌 키보드에서 누른 키 한개씩 읽고 싶을 때
키보드 **키 하나를 입력**하면 프로그램에서는 숫자로 된 **키코드**를 읽을 수 있다.
키코드 읽기 위해서 **System.in의 read() 이용**

**💡 주요 키코드**
- 숫자, 알파벳 : ASCII 코드와 동일
- 기능키
  - ENTER키 : 다른 키와 다르게 캐리지 리턴과 라인 피드로 구성된 2개의 키코드가 입력됨, 따라서 2번에 걸쳐 읽어야함
<img width="270" height="400" alt="image" src="https://github.com/user-attachments/assets/d9b19b7b-5993-42c0-ba01-3ad207889af4" />

- 방향키
<img width="270" height="180" alt="image" src="https://github.com/user-attachments/assets/061a9912-fec9-4e78-8284-0dae63c93df9" />

#### 📌 통 문자열을 읽어야할 때
**Scanner 클래스** 이용
<img width="500" height="250" alt="image" src="https://github.com/user-attachments/assets/5ce98a6a-d8e2-4165-b795-60589b203b6c" />
