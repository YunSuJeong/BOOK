# chap02. 변수와 타입

## 02-1. 변수
> 컴퓨터 메모리(RAM)는 값을 저장할 수 있는 수많은 번지(주소)로 구성되어 있다.  
> **메모리에 값을 저장하고 싶다면 변수를 사용해 값을 지정**하면 된다.  
> 그러면 메모리의 어디에 저장하고, 어떤 방식으로 저장할지는 프로그래밍 언어와 운영체제가 정한다!  
> 자바의 경우는 JVM이 하는 일!

`변수(variable) : 값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름`  

### ▶︎ 변수 선언
변수에 어떤 `타입`의 데이터를 저장할 것인지, 변수 이름이 무엇인지 결정하는 것  
`타입 : 변수에 저장되는 값의 종류와 범위를 결정`
```java
// 따로 선언한 예시
int x;
int y;
int z;

// 같은 타입인 경우만 한번에 선언 가능
int x, y, z;      
```

#### 변수 이름 명명규칙
- 첫 번째 글자는 문자, '$', '_'이어야하고 숫자로 시작할 수 없다
  - 불가능한 예) 1v, @speed
- 영어 대소문자를 구분한다
  - firstname firstName은 다른 변수
- 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로
  - 예) maxSpeed, carBodyColor
- 길이 제한은 없다
- `예약어`는 사용할 수 없다.

`예약어 : 이미 해당 프로그래밍 언어에서 의미를 갖고 사용되고 있는 단어`

### ▶︎ 값 저장
**대입 연산자(=)** 사용하여 값을 저장할 수 있고
```java
int score;      // 선언
score = 90;     // 값 저장(초기값)

// 선언과 생성을 동시에
int score = 90;
```

‼️ **자바에서는 변수에 값이 저장되지 않으면 변수가 생성되지 않는다.** (선언 ≠ 생성)  
**변수에 최초로 값이 저장될 때 변수가 생성**된다 **= 변수 초기화**  
변수가 초기화되면 메모리 번지 정보를 갖게되고, 해당 메모리 번지에 값이 저장된다.

따라서 초기화되어 있지 않은 변수를 가져다 사용하려고 하면, '변수가 존재하지 않는다'는 컴파일 에러를 마주치게 된다.

### ▶︎ 변수 사용
- 변수는 출력문이나 연산식 내부에서 변수에 저장된 값을 출력하거나 연산할 때 사용  
- 또 다른 변수에 대입하여 값을 복사할 수도 있다
```java
int x = 10;
int y = x;      // x에 저장된 값을 y에 복사(저장)
```
### ▶︎ 변수 사용 범위
자바의 모든 변수는 중괄호 {} 블록 내에서 선언되고 사용된다.  
자신이 선언된 위치로부터 자신이 속한 블록 내부에서만 사용가능하고 밖에서는 사용할 수 없다.  

#### 📌 로컬 변수(local variable)
메소드 블록 내에서 선언된 변수  
메소드 블록 내에서만 사용되고 실행이 끝나면 메모리에서 자동으로 없어진다.

```java
public void cafe() {
  int price;
  if(...) {
    // 여기선 price 사용가능
    int option
  }
  // 여기선 option 사용 불가능
}
```

## 02-2. 기본 타입
기본 타입(primitive type) : 자바에서 제공하는 정수, 실수, 논리 값을 저장 할 수 있다.  
총 8가지!  
각 분류별 타입 종류들은 **메모리 사용 크기와 저장되는 범위가 서로 다르다**. 

<table>
  <tr>
    <th>구분</th>
    <th>저장되는 값에 따른 분류</th>
    <th>타입의 종류</th>
  </tr>
  <tr>
    <td rowspan="3">기본 타입</td>
    <td>정수 타입</td>
    <td>byte, char, short, int, long</td>
  </tr>
  <tr>
    <td>실수 타입</td>
    <td>float, double</td>
  </tr>
  <tr>
    <td>논리 타입</td>
    <td>boolean</td>
  </tr>
</table>

### ▶︎ 정수 타입
char를 제외한 저장되는 값의 허용 범위는 **-2<sup>n-1</sup>~(2<sup>n-1</sup>-1)** 이다.
(n은 메모리 bit수)  

정수 타입으로 선언된 변수에는 정수 `리터럴`을 대입해 저장할 수 있다.  
`리터럴(literal) : 프로그래머에 의해 직접 입력된 값, 상수풀에 저장된 후 변수 메모리에 복사됨`

> 💡 정수 리터럴
> 2진수 : 0b | 0B 로 시작하고 0,1로 구성  
> 8진수 : 0으로 시작하고 0-7로 구성  
> 10진수 : 소수점이 없는 0-9로 구성  
> 16진수 : 0x | 0X로 시작하고 0-9, A-F(a-f)로 구성  

‼️ 각 타입 변수에 **허용 범위를 초과한 값을 대입**한 경우 **'Type mismatch' 컴파일 에러**가 발생한다.

| 타입 | 메모리 사용 크기 | 저장되는 값의 허용 범위 |
|---|---|---|
| byte | 1byte | -128 ~ 127 |
| short | 2byte | -32,768 ~ 32,767 |
| char | 2byte | 0 ~ 65535(유니코드) |
| int | 4byte | -2,147,483,648 ~ 2,147,483,647 |
| long | 8byte | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

#### 📌 long 타입 
기본적으로 컴파일러는 정수 리터럴을 int타입으로 간주한다.  
따라서 **long 타입 변수에 정수 리터럴을 저장할 때, 정수 리터럴이 int타입 범위를 초과할 경우 리터럴 뒤에 L(l)** 을 붙여야한다.

```java
long var1 = 3000000000000;        // 컴파일 에러
long var2 = 3000000000000L;
```

#### 📌 char 타입 
**하나의 문자를 저장**할 수 있는 타입  

**문자 리터럴** : 하나의 문자를 작은따옴표(')로 감싼 것  
문자 리터럴은 `유니코드`로 변환되어 저장된다.  

**char변수에도 10진수 또는 16진수 형태로 유니코드 저장할 수 있다.** 유니코드도 정수이기 때문!  
`유니코드(Unicode) : 세계 각국의 문자를 2byte로 표현할 수 있는 숫자(0-65535)로 매핑한 국제 표준 규약`  

> 💡 문자 리터럴은 int 타입에 저장이 가능할까.?  
> 작은 따옴표로 감싼 문자 리터럴은 유니코드로 변환되기 때문에 int타입 변수에 저장할 수 있다.  
> 다만 출력 시에는 유니코드 자체가 출력된다.  
> 예) int var = 'A' (가능!) → 65로 출력됨

#### 📌 문자열 타입(String)
> String타입은 기본 타입이 아니지만, 기본 타입 못지않게 많이 쓰이기 때문에 문자 타입과 함께 가볍게 언급하고 넘어가고자 한다.  
> 6장에서 상세히 설명될 예정

`문자열`을 저장할 수 있는 타입이다.  
큰따옴표로 감싼 문자 또는 여러 개의 문자들은 유니코드로 변환되지 않기 때문에 String타입에 저장하여 사용한다.  
`문자열 : 큰따옴표(")로 감싼 문자들`  

문자열에는 `이스케이프 문자`라는 것이 있다.
`이스케이프(escape) 문자 : 문자열 내부에 역슬래시(\)가 붙은 문자`
출력을 제어하거나, 특정 문자를 문자열 내부에 포함시키고 싶을 때 사용한다.

| 이스케이프 문자 | 출력 용도 |
|---|---|
| \t | 탭만큼 띄움 |
| \n | 줄 바꿈(라인 피드) |
| \r | 캐리지리턴 |
| \" | " 출력 |
| \' | ' 출력 |
| \\ | \ 출력 |
| \u16진수 | 16진수 유니코드에 해당하는 문자 출력 |

### ▶︎ 실수 타입
소수점이 있는 실수 리터럴을 저장할 수 있는 타입 
| 타입 | 메모리 사용 크기 | 저장되는 값의 허용 범위(양수 기준) | 정밀도(소수점 이하 자리) |
|---|---|---|---|
| float | 4byte | (1.4 × 10<sup>-45</sup>) ~ (3.4 × 10<sup>38</sup>) | 7자리 |
| double | 8byte | (4.9 × 10<sup>-324</sup>) ~ (1.8 × 10<sup>308</sup>) | 15자리 |

자바는 실수 리터럴을 기본적으로 double타입으로 간주한다.  
따라서 **float 타입 변수에 실수 리터럴을 저장할 때, 리터럴 뒤에 F(f)** 를 붙여야한다.

```java
float var1 = 3.14;        // 컴파일 에러(Type mismatch)
float var2 = 3.14F;
double var2 = 3.14;
```

### ▶︎ 논리 타입
주로 **두 가지 상태값에 따라** 조건문과 제어문의 실행 흐름을 변경하는 데 사용한다.  
자바는 참과 거짓을 의미하는 **논리 리터럴로 true/false**를 사용한다. 

## 02-3. 타입 변환
