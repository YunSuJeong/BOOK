# 참조 타입
> 자바 타입은 크게 기본 타입(primitive type)과 참조 타입(reference type)으로 분류된다.  
> 기본 타입은 2장에서 다뤘고, 이번 장에선 참조 타입에 대해 알아보자

## 05-1. 참조 타입과 참조 변수
### ▶︎ 기본타입과 참조 타입
`참조 타입(reference type) : 번지를 통해 객체를 참조하는 타입`  

기본 타입과 참조 타입의 차이점은 저장되는 값이다.  
기본 타입은 실제 값을 저장하지만, **참조타입은 메모리의 번지를 변수에 저장**한다.  
종류 : 배열, 열거, 클래스, 인터배이스

#### 📌 메모리에서 변수들이 갖는 값
<img width="1466" height="622" alt="image" src="https://github.com/user-attachments/assets/97955c06-5841-4903-8a6e-18cda5fb6da1" />

### ▶︎ 메모리 사용 영역
자바에서 JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 세부 영역으로 구분해서 사용한다.
<img width="700" height="600" alt="image" src="https://github.com/user-attachments/assets/866cd005-ebf9-4ab2-b98d-5ec4658225a7" />

#### 📌 메소드 영역(Method Area)
JVM이 시작할 때 생성되며, 모든 스레드가 공유하는 영역  
코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 정적필드와 상수, 메소드 코드, 생성자 코드 등을 분류해서 저장

#### 📌 힙 영역(Heap Area)
객체와 배열이 생성되는 영역  

여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.  
**만약 참조하는 변수나 필드가 없다면 JVM이 이것을 쓰레기로 취급하고 쓰레기 수집기(Garbage Collector)를 실행시켜 자동으로 제거**한다.

#### 📌 JVM 스택 영역
메소드를 호출할 때마다 프레임(Frame)을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행  

프레임 내부에는 로컬 변수 스택이 있고, 스택에 기본 타입 변수와 참조 타입 변수가 추가되거나 제거된다.  
스택 영역에 변수가 생성되는 시점 : 변수가 초기화 될 때  
변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

### ▶︎ 참조 변수의 ==, != 연산
동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다.  

**참조 타입 변수의 값은 힙 영역의 객체 주소이므로 ==, != 연산은 번지 값을 비교하는 것!**
'동일한 번지 값을 갖고 있다' = '동일한 객체를 참조한다'

### ▶︎ null과 NullPointerException
#### 📌 null
null = 참조 타입 변수가 힙 영역의 객체를 참조하지 않는다

null값을 초기값으로 사용할 수 있다.  
따라서 null로 초기화된 참조 변수는 스택 영역에 생성된다.  
참조 타입변수가 null값을 가지는지 확인하려면 ==, != 연산 수행하면 된다.  

#### 📌 NullPointerException
참조 변수를 사용하면서 가장 많이 발생하는 `예외` 중 하나  
참조 변수가 null을 가지고 있을 경우에는, 참조 객체가 없으므로 변수를 통해 객체를 사용할 수 없다.
```java
int[] intArr = null;
intArr[0] = 10;                      // NullPointerException

String str = null;
System.out.println(str.length());    // NullPointerException
```

`예외(Exception) : 프로그램 실행 도중에 발생하는 오류`  

### ▶︎ String 타입
문자열을 저장할 수 있는 참조 변수

문자열 저장 방식
- String변수 우선 선언 후, 문자열 리터럴 대입
- 선언과 동시에 문자열 저장
- `new 연산자`를 이용하여 직접 String 객체 생성하기
  - `new 연산자 : 힙 영역에 새로운 객체를 만들 때 사용하는 연산자, 객체 생성 연산자`
```java
// 1) 변수 선언과 초기화를 동시에
String hobby = "LOL";

// 2) new 이용
String hobby = new String("LOL");
```

일반적으로는 '문자열을 String변수에 저장한다'라고 말하지만, 사실 이는 엄밀히 말해 틀린 표현이다  
문자열이 직접 변수에 저장되는 것이 아니라, String 객체로 생성되고 변수는 String객체를 참조하기 때문  
**String 변수에는 객체의 번지 값이 저장**된다.  

**‼️ 자바는 문자열 리터럴이 동일하다면 String객체를 공유하도록 되어있다.**  
**그러나 문자열 리터럴이 동일하더라도 new를 이용하여 직접 객체를 생성한다면 서로 다른 객체를 참조한다.**

```java
// 1) name1, name2가 동일한 문자열 리터럴 "신용권"을 참조하는 경우, 동일한 String객체를 참조한다
String name1 = "신용권";
String name2 = "신용권";

if( name1 == name2 )       // true
```
<img width="700" height="200" alt="image" src="https://github.com/user-attachments/assets/2c72be18-78cd-4a90-9551-b83ededaf74b" />


```java
// 2) 직접 객체 생성, 서로 다른 String 객체를 참조한다
String name1 = new String("신용권");
String name2 = new String("신용권");

if( name1 == name2 )       // false
```
<img width="700" height="300" alt="image" src="https://github.com/user-attachments/assets/a6efea2c-9d41-4586-95b0-779eefdc812d" />

#### 📌 문자열 리터럴을 비교하고 싶을 때, equals() 메소드 
- 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교한 후 true 또는 false를 리턴한다.
- 원본 문자열.equals(비교 문자열)
```java
String name1 = "신용권";
String name2 = "신용권";
String name3 = "신용";

boolean result = str1.equals(str2);      // true
boolean result = str1.equals(str3);      // false
```



## 05-2. 배열
### ▶︎ 배열이란?
같은 타입의 데이터를 연속된 공간에 나열하고, 각 데이터에 인덱스(index)를 부여해놓은 자료구조  
인덱스 범위는 0~(길이-1) 이다.
#### 📌 특징
- 같은 타입의 데이터만 저장 할 수 있다.
- 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.

#### 📌 배열 선언
아래와 같이 두 가지 방식이 있다
```java
타입[] 변수
타입 변수[]
```
- 타입은 배열에 저장될 데이터의 타입
- 배열 변수는 참조 변수
- 배열도 객체이므로 힙 영역에 생성되고, 배열 변수는 힙 영역의 배열 객체를 참조하게 된다

#### 📌 배열 생성
1) 값 목록으로 배열 생성
```java
타입[] 변수 = {값0, 값1, 값2, 값3, ...};
```
- 중괄호{} : 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴
- 배열의 초기화와 생성을 동시에 한다

**‼️ 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용하여 배열을 생성할 수 없다.**  
**배열 변수를 미리 선언한 후 값 목록이 나중에 결정되는 상황이라면, new를 이용하여 값 목록을 지정해야한다.**  
**메소드의 매개값이 배열일 경우도 new 이용해야한다.**  
```java
타입[] 변수;                                  // 선언

변수 = {값0, 값1, 값2, 값3, ...};              // ❌ 다른 실행문에서 생성 불가능
변수 = new 타입[] {값0, 값1, 값2, 값3, ...};    // ✅ new를 이용하면 나중에 배열 생성 가능
```
2) new 연산자로 배열 생성
```java
타입[] 변수 = new 타입[길이];
```
- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶을 때
- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값을 초기화된다
  - int배열 → 0으로 초기화
  - String배열 → null 값으로 초기화
<img width="450" height="400" alt="image" src="https://github.com/user-attachments/assets/b46faf0c-a6f8-41eb-bda1-1930ad7ec9f4" />

#### 📌 배열 생성 후, 특정 인덱스 위치에 새로운 값 저장하기
대입 연산자를 이용한다
```java
변수[인덱스] = 값;
```
#### 📌 배열 길이
- 배열에 저장할 수 있는 전체 항목의 개수
- 배열 객체의 `필드` 중 하나
  - `필드 : 객체 내부의 데이터`
- 배열 변수.length로 구할 수 있다
- 인덱스를 초과하여 사용하면 ArrayIndexOutOfBoundsException이 발생한다

#### 📌 배열 복사
배열은 한 번 생성하면 크기를 변경할 수 없다.  
따라서 더 많은 저장 공간이 필요하다면 더 큰 배열을 새로 만들고, 이전 배열로부터 항목 값을 복사해야 한다.  

**‼️ 참조 타입 배열이 복사되면 복사되는 값이 객체의 번지이므로 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일하다.**  
**즉, 객체가 변경되면 원본 배열에도 영향이 간다.**  
**배열을 복사하여 사용할 땐 원본 변경을 조심할 것!**

배열 간의 항목 값들을 복사하는 방법은 아래와 같다.
1) for문 사용
2) **System.arraycopy() 메소드 사용**

```java
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
```
- src : 원본 배열
- srcPos : 원본 배열에서 복사할 항목의 시작 인덱스
- dest : 새 배열
- destPos : 새 배열에서 붙여넣을 시작 인덱스
- length : 복사 할 개수


### ▶︎ 다차원 배열
배열 항목(값)이 또 다른 배열을 참조할 때 사용  
여기선 2차원 배열을 다룬다  

2차원 배열 : 값들이 행과 열로서 구성된 배열로, 가로 세로 인덱스를 사용한다.
```java
int[][] scores = new int[2][3];

scores.length        // 2 : 배열 A의 길이
scores[0].length     // 3 : 배열 B의 길이
scores[1].length     // 3 : 배열 C의 길이
```
<img width="750" height="350" alt="image" src="https://github.com/user-attachments/assets/697f3b79-abdb-4a59-a5e3-6d750a6c50b2" />

**‼️ 1차원 배열이 서로 연결된 구조로 다차원 배열을 구현하기 때문에, 계단식 구조를 가질 수 있다.**  
이런 형태의 배열에선 배열의 정확한 길이를 알고 인덱스를 사용해야한다.

```java
int[][] scores = new int[2][];      // 열의 길이를 정하지 않고, 각 행의 길이를 다르게 생성할 수 있다

scores[0] = new int[2];             // 첫번째 배열은 길이 2
scores[1] = new int[3];             // 두번째 배열은 길이 3
```

### ▶︎ 객체를 참조하는 배열
기본 타입 배열은 각 항목에 직접 값을 가지고 있다.  
그러나 **참조 타입 배열은 각 항목에 객체의 번지를 가지고 있다.**  
